
<script>

// https://stackoverflow.com/questions/22521982/check-if-point-is-inside-a-polygon
function inside(point, vs) {
  // ray-casting algorithm based on
  // https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html

  var x = point[0], y = point[1];

  var inside = false;
  for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
      var xi = vs[i][0], yi = vs[i][1];
      var xj = vs[j][0], yj = vs[j][1];

      var intersect = ((yi > y) != (yj > y))
          && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
      if (intersect) inside = !inside;
  }

  return inside;
};

function circumcircle (points, radiusSq = false) {
	const EPSILON = 1.0e-6;
	const circle = {};

	const ax = points[0][0];
	const ay = points[0][1];
	const bx = points[1][0];
	const by = points[1][1];
	const cx = points[2][0];
	const cy = points[2][1];

	const A = bx - ax;
	const B = by - ay;
	const C = cx - ax;
	const D = cy - ay;

	const E = A * (ax + bx) + B * (ay + by);
	const F = C * (ax + cx) + D * (ay + cy);

	const G = 2 * (A * (cy - by) - B * (cx - bx));

	let dx, dy;

	if (Math.abs(G) < EPSILON) {
		const minx = Math.min(ax, bx, cx);
		const miny = Math.min(ay, by, cy);
		const maxx = Math.max(ax, bx, cx);
		const maxy = Math.max(ay, by, cy);

		circle.x = (minx + maxx) * 0.5;
		circle.y = (miny + maxy) * 0.5;

		dx = circle.x - minx;
		dy = circle.y - miny;
	}
	else {
		const cx = (D * E - B * F) / G;
		const cy = (A * F - C * E) / G;

		circle.x = cx;
		circle.y = cy;

		dx = circle.x - ax;
		dy = circle.y - ay;
	}

	// radius squared
	circle.r = dx * dx + dy * dy;

	// radius
	if (!radiusSq) circle.r = Math.sqrt(circle.r);

	return circle;
}

</script>

<script>
  function square () {
    return [
             [5 ,5],
             [5, 95],
             [95, 95],
             [95, 5],
           ]
  }

  function parallelo1 () {
    return [
             [0 ,0],
             [20, 100],
             [120, 100],
             [110, -20],
             [50, 20],
             [0, 0]
           ]
  }

  function parallelo2 () {
    return [
             [0 ,0],
             [10, 20],
             [10, 80],
             [0, 100],
             [80, 100],
             [90,80],
             [90,20],
             [80, 0],
             [0, 0]
           ]
  }

  function rescale (points, w, h) {
    const xs = points.map((p) => { return p[0] })
    const ys = points.map((p) => { return p[1] })
    const xmin = Math.min(...xs)
    const xmax = Math.max(...xs)
    const ymin = Math.min(...ys)
    const ymax = Math.max(...ys)
    const xsc = xmax - xmin
    const ysc = ymax - ymin

    const sc = Math.max(xsc, ysc)

    return points.map((p) => { return [(p[0] - xmin) / sc * w, (p[1] - ymin) / sc * h] })
  }

  function parallelo () {
    const points = [[-92, -131], [-157, -70], [-176, 28], [-144, 107], [-87, 125], [-48, 77], [6, 84], [94, 131], [128, 129], [148, 64], [176, 61], [151, -15], [171, -78], [121, -119], [53, -125], [16, -65], [-31, -39], [-50, -44], [-40, -111], [-92, -131]]

    return rescale(points, 100, 100)
  }

  function parallelo4 () {
    return rescale([[-70.5, -56], [-82.5, 58], [-4.5, -7], [73.5, 64], [82.5, -64], [29.5, -10], [29.5, -10], [29.5, -10], [-70.5, -56]], 100, 100)
  }

  function parallelo_sq () {
    return rescale([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]], 100, 100)
  }

  function neighbors (triangles, triangle) {
    const verts = new Set(triangle.slice(0, 3))
    const neighbors = []
    for (const overts of triangles) {
      if (overts[3] === triangle[3]) { continue }

      for (const v of overts.slice(0, 3)) {
        if (verts.has(v)) {
          neighbors.push(overts)
          break
        }
      }
    }
    return neighbors
  }

  function delaunyTriangulate(points) {
    const delaunay = new Delaunay(points);
    const triangleVerts = delaunay.triangulate();
    // const circles = circumcircle(

    const triangles = []
    for (let j = 0; j < triangleVerts.length / 3; ++j) {
      const v = triangleVerts.slice(j * 3, j * 3 + 3)
      const centroid = [(v[0][0] + v[1][0] + v[2][0]) / 3, (v[0][1] + v[1][1] + v[2][1]) / 3]
      // if (!inside(centroid, points)) { continue }
      v.push(j)
      v.push(centroid)
      triangles.push(v)
    }

    return triangles
  }

  function pointAlongNormal(p, n, scale) {
    return [p[0] + scale * n[0], p[1] + scale * n[1]]
  }

  function MAT (points, r_thresh = 99999999999) {
    const triangles = delaunyTriangulate(points)
    const circs = triangles.map(function (tri) { return circumcircle(tri) } )

    // filtering triangles that have radius > thresh
    // simp_pts_0 = dt.points[dt.simplices[:, 0]]
    // radii = np.linalg.norm(xy_centers - simp_pts_0, axis=1)
    // is_in = radii < r_thresh

    // build an edge list from (filtered) triangle neighbor relations
    const edgeList = []
    for (const [i, triangle] of triangles.entries()) {
        //if not is_in[i]:
        //    continue  # i is an outside triangle (large radius)
        for (const nb of neighbors(triangles, triangle)) {
            //if j != -1 and is_in[j]:
              // edgeList.push([circs[i], circs[nb[3]]])
              edgeList.push([triangle[4], nb[4]])
        }
    }

    return edgeList
  }

  // Radius of circle through p1 and p2 whose center lines on pt->normal
  function circleTwoPointNormal(p1, p2, nm) {
    // P1, P1, <center of circle> form Isoceles triangle.
    // Find intersection of P1 normal and normal of (P2 - P1) at its middle.
    const x1 = p1[0]
    const y1 = p1[1]
    const x2 = p1[0] + 100 * nm[0]
    const y2 =  p1[1] + 100 * nm[1]

    const x3 = p1[0] + (p2[0] - p1[0]) / 2
    const y3 =  p1[1] + (p2[1] - p1[1]) / 2
    const n2 = normal(p1, [x3, y3])
    const x4 = x3 + 100 * n2[0]
    const y4 = y3 + 100 * n2[1]

    const t1 = (x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)
    const t2 = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)
    const t = t1 / t2

    const center = [x1 + t * (x2 - x1), y1 + t * (y2 - y1)]

    const dx = center[0] - p1[0]
    const dy = center[1] - p1[1]
    const r = Math.sqrt(dx * dx + dy * dy)
    return [center, r, [x3, y3], n2]
  }

  /*
   * Shrinking-Balls Approximation of the Medial Axis Transform.
   */
  function SBMAT (points, iter_dist=1.0) {
    const d = Draw()
    function normal(p1, p2) {
      const dx = p2[0] - p1[0]
      const dy = p2[1] - p1[1]

      const l = Math.sqrt(dx*dx + dy*dy)
      return [-dy / l, dx / l]
    }

    function normal_dist(p1, p2) {
      const dx = p2[0] - p1[0]
      const dy = p2[1] - p1[1]

      const l = Math.sqrt(dx*dx + dy*dy)
      return [[-dy / l, dx / l], l]
    }

    function normalInside (p1, p2, atPt, points) {
      let n = normal(p1, p2)
      let nx = atPt[0] + 0.1 * n[0]
      let ny = atPt[1] + 0.1 * n[1]
      if (!inside([nx, ny], points)) {
        n[0] = -n[0]
        n[1] = -n[1]
      }
      return n
    }

    function closestPoint(points, p, butNotP) {
      let res = null
      let dist = Number.POSITIVE_INFINITY

      for (pp of points) {
        const dx = p[0] - pp[0]
        const dy = p[1] - pp[1]

        if (butNotP && eq(pp[0], butNotP[0]) && eq(pp[1], butNotP[1])) { continue }

        const l = dx * dx + dy * dy
        if (l < dist) {
          dist = l
          res = pp
        }
      }

      return res
    }

    function eq(a, b) { return Math.abs(a - b) < Number.EPSILON }

    const len = points.length
    function mod(n, m) {
      return ((n % m) + m) % m;
    }

    const closedPoints = points.concat([points[0]])
    function iterBalls(pt, i, r) {
      const p3 = points[mod(i - 1 , len)]
      const ppt = points[i % len]
      const p1 = points[mod(i + 1, len)]

      d.clear()
      d.polygon(closedPoints)

      // Find normal - when pt falls on a polygon point use p1 and p3, otherwise closest of those points and pt.
      let n = null
      //if (eq(pt[0], ppt[0]) && eq(pt[1], ppt[1])) {
        n = normalInside(p1, p3, ppt, points)
      /*} else {
        n = normalInside(p1, ppt, pt, points)
        const lines = [ [pt, [pt[0] + 100 * n[0], pt[1] + 100 * n[1]]] ]
        d.lines(lines, 'lightblue')
      }*/

      let nx = pt[0] + r * n[0]
      let ny = pt[1] + r * n[1]
      let px = nx
      let py = ny
      let center = [nx, ny]

      do {
        d.clear()
        d.polygon(closedPoints)

        const circles = [{x: center[0], y: center[1], r: Math.abs(r) }]
        d.circles(circles, 'yellow', 2)

        const pc = closestPoint(points, [nx, ny], pt)
        const center_r = circleTwoPointNormal(pt, pc, n)
        center = center_r[0]
        r = center_r[1]

        d.points([center_r[2]], 'pink')
        d.lines([[center_r[2], pointAlongNormal(center_r[2], center_r[3], 100)]], 'orange')

        const pts = [p1, pt, p3]
        d.points(pts, color = 'green')

        // const pointsOrg = [pt, p1, p3]
        // d.points(pointsOrg, '$ff0')

        d.points([[px, py]], '#7f7', 4)
        d.points([[nx, ny]], '#fff', 4)
        d.points([pc], 'blue', 4)

        const lines = [ [pt, [pt[0] + 100 * n[0], pt[1] + 100 * n[1]]] ]
        d.lines(lines, 'blue')

        px = nx
        py = ny

        nx = center[0]
        ny = center[1]
      } while (!eq(px, nx) && !eq(py, ny))

      return { x: nx, y: ny, r: r }
    }

    return points.map(function (p, i) {
      const pt = points[i % len]
      const pt_next = points[mod(i + 1, len)]
      const nd = normal_dist(pt, pt_next)
      const mx = [nd[0][1], -nd[0][0]]
      const l = nd[1]

      const k = Math.ceil(l / iter_dist)
      const step = l / k

      res = []
      for (let lerp = 0; lerp < k; ++lerp) {
        const pp = pointAlongNormal(pt, mx, step * lerp)
        const rp = iterBalls(pp, i, 80)
        d.points(res.map(function (p) { return [p.x, p.y] }), 'red', 4)
        d.points([[rp.x, rp.y]], 'red', 4)
        res.push(rp)
      }
      return res
    }).flat()
  }

  function Draw (scale = 100) {
    const canvas = document.getElementById('canvas')
    if (!canvas.getContext) {
      window.alert('Cannot get context for canvas')
      throw new Error('canvas.getContext not defined')
    }

    const ctx = canvas.getContext('2d')

    const w = canvas.width / 2
    const h = canvas.height / 2
    const w2 = w / 2
    const h2 = h / 2

    const xx = function (c) { return w2 + w * c / 100 }
    const yy = function (c) { return h2 + h * c / 100 }
    const pointXY = function (x, y) { return [xx(x), yy(y)] }
    const pointA = function (p) { return pointXY(p[0], p[1]) }

    const point = function (p) { return pointXY(p.x, p.y) }

    const clear = function (color = '#000') {
      ctx.beginPath()
      ctx.moveTo(0, 0)
      ctx.lineTo(w * 2, 0)
      ctx.lineTo(w * 2, h * 2)
      ctx.lineTo(0, h * 2)
      ctx.closePath()
      ctx.fill()
    }

    const dash = function () { ctx.setLineDash([5, 3]) }
    const undash = function () { ctx.setLineDash([]) }

    const triangles = function (tri, color = 'white', lineWidth = 2) {
      ctx.strokeStyle = color
      ctx.lineWidth = lineWidth
      for (tri of triangles) {
        ctx.beginPath()
        ctx.moveTo(w2 + w * tri[0][0] / 100, h2 + h * tri[0][1] / 100)
        ctx.lineTo(w2 + w * tri[1][0] / 100, h2 + h * tri[1][1] / 100)
        ctx.lineTo(w2 + w * tri[2][0] / 100, h2 + h * tri[2][1] / 100)
        ctx.closePath()
        ctx.stroke()
      }
    }

    const polygon = function (points, color = "#00ff0077", lineWidth = 4) {
      ctx.strokeStyle = color
      ctx.lineWidth = lineWidth

      if (points && points.length > 0) {
        ctx.beginPath()
        ctx.moveTo(xx(points[0][0]), yy(points[0][1]))
        for (p of points) {
          ctx.lineTo(xx(p[0]), yy(p[1]))
        }
        //ctx.closePath()
        ctx.stroke()
      }
    }

    const circles = function (circles, color = "#ff000099", lineWidth = 2) {
      ctx.strokeStyle = color
      ctx.lineWidth = lineWidth

      for (c of circles) {
        ctx.beginPath()
        ctx.arc(w2 + w * c.x / 100, h2 + h * c.y / 100, w * c.r / 100, 0, 2 * Math.PI, false)
        ctx.stroke()
      }
    }

    const points = function (points, color = "#0000ff99", lineWidth = 2, radius = 1) {
      circles(points.map(function (e) { return {x: e[0], y: e[1], r: radius } }), color, lineWidth)
    }

    const lines = function (lines, color = "#0000ff99", lineWidth = 2) {
      ctx.strokeStyle = color
      ctx.lineWidth = lineWidth

      for (p of lines) {
        ctx.beginPath()
        if (Array.isArray(p[0])) {
          ctx.moveTo(xx(p[0][0]), yy(p[0][1]))
          ctx.lineTo(xx(p[1][0]), yy(p[1][1]))
        } else {
          ctx.moveTo(xx(p[0].x), yy(p[0].y))
          ctx.lineTo(xx(p[1].x), yy(p[1].y))
        }
        ctx.stroke()
      }
    }

    return {clear, points, lines, circles, polygon, triangles, dash, undash}
  }

  function draw (points, triangles, circles, lines) {
    const canvas = document.getElementById('canvas')
    if (canvas.getContext) {
      const ctx = canvas.getContext('2d')
      ctx.fillStyle = "#000000"

      ctx.beginPath()
      ctx.moveTo(0, 0)
      ctx.lineTo(w * 2, 0)
      ctx.lineTo(w * 2, h * 2)
      ctx.lineTo(0, h * 2)
      ctx.closePath()
      ctx.fill()

      ctx.strokeStyle = "white"
      ctx.lineWidth = 2
      for (tri of triangles) {
        ctx.beginPath()
        ctx.moveTo(w2 + w * tri[0][0] / 100, h2 + h * tri[0][1] / 100)
        ctx.lineTo(w2 + w * tri[1][0] / 100, h2 + h * tri[1][1] / 100)
        ctx.lineTo(w2 + w * tri[2][0] / 100, h2 + h * tri[2][1] / 100)
        ctx.closePath()
        ctx.stroke()
      }

      ctx.strokeStyle = "#00ff0077"
      ctx.lineWidth = 4

      function xx(c) { return w2 + w * c / 100 }
      function yy(c) { return h2 + h * c / 100 }

      if (points && points.length > 0) {
        ctx.beginPath()
        ctx.moveTo(xx(points[0][0]), yy(points[0][1]))
        for (p of points) {
          ctx.lineTo(xx(p[0]), yy(p[1]))
        }
        //ctx.closePath()
        ctx.stroke()
      }

      ctx.strokeStyle = "#ff000099"
      ctx.lineWidth = 2

      for (c of circles) {
        ctx.beginPath()
        ctx.arc(w2 + w * c.x / 100, h2 + h * c.y / 100, w * c.r / 100, 0, 2 * Math.PI, false)
        ctx.stroke()
      }

      ctx.strokeStyle = "#0000ff99"
      ctx.lineWidth = 2

      for (p of lines) {
        ctx.beginPath()
        ctx.moveTo(xx(p[0][0]), yy(p[0][1]))
        ctx.lineTo(xx(p[1][0]), yy(p[1][1]))
        //ctx.moveTo(xx(p[0].x), yy(p[0].y))
        //ctx.lineTo(xx(p[1].x), yy(p[1].y))
        ctx.stroke()
      }

    }
  }

    function normal(p1, p2) {
      const dx = p2[0] - p1[0]
      const dy = p2[1] - p1[1]

      const l = Math.sqrt(dx*dx + dy*dy)
      return [-dy / l, dx / l]
    }

  function adaptive() {
    const points = parallelo()
    // const triangles = delaunyTriangulate(points.slice())
    // const circles = triangles.map(function (tri) { return circumcircle(tri) } )
    // const lines = MAT(points.slice())
    // draw(points, triangles, circles, lines)

    const matPoints = SBMAT(points.slice(0, points.length - 1))
    const d = Draw()

    d.polygon(points, 'green')
    d.circles(matPoints, '#00ff0044')
    const pts = matPoints.map(function (el) { return [el.x, el.y] })
    d.points(pts, 'white', 2)
  }

  function testCircleTwoPoint () {
    const p1 = [0, 50]
    const p2 = [100, 50]
    const n = [1, 0]
    const res = circleTwoPointNormal(p1, p2, n)
    const [center, r, p3, m] =res

    const d = Draw()
    d.lines([[p1, [p1[0] + 100* n[0], p1[1] + 100 * n[1]]]])
    d.points([p1, p2], 'green')
    d.points([p3], 'purple')
    d.lines([[p3, [p3[0] + 100* m[0], p3[1] + 100 * m[1]]]], 'purple')

    d.circles([{x: center[0], y: center[1], r: r}])
  }

  function docReady(fn) {
    // see if DOM is already available
    if (document.readyState === "complete" || document.readyState === "interactive") {
        // call on next available tick
        setTimeout(fn, 1);
    } else {
        document.addEventListener("DOMContentLoaded", fn);
    }
  }

  docReady(function () { adaptive() })
</script>

<style>canvas { border: 1px solid red; }</style>


<html>
  <body>
    <div id="main">
      <canvas width='600px' height='600px' id="canvas" />
    </div>
  </body>
</html>
